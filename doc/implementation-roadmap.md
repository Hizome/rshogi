> [!WARNING]
> 本文档中涉及 GPUI 的技术栈建议已废弃（2026-02-14）。  
> 当前项目默认与唯一实现基线为 `egui/eframe`。

# rshogi 实现路线与技术栈建议

本文给出一个可直接执行的项目落地方案，重点覆盖：

- 采用什么技术栈
- 按什么顺序实现
- 每个阶段做到什么算完成

## 1. 项目目标（先统一边界）

构建一个纯 Rust 的本地将棋 GUI 应用，核心目标：

1. 流畅棋盘交互（走子、打入、升变）
2. 对接本地 USI 引擎（如 YaneuraOu）
3. 提供基础分析 UI（分数、PV、深度）
4. 后续可扩展棋谱、主题、音效和更多引擎

不在第一阶段追求：

- 多变体全覆盖
- 云分析系统
- 复杂在线对战功能

## 2. 推荐技术栈

## 2.1 语言与框架

- `Rust`：主语言
- `GPUI`：桌面 UI 渲染与交互
- `gpui-component`：可选，用于快速搭建设置页/控件页（非必须）

## 2.2 领域与协议

- 将棋规则：`shogi`（或你最终选定的规则库）
- 协议：USI（文本协议，自实现 parser + 状态机）

## 2.3 并发与通信

- 进程管理：`std::process::Command`
- 并发：`tokio` 或 `std::thread`
- 通道：`std::sync::mpsc` / `crossbeam-channel`

建议：先用标准库线程 + channel 跑通，再考虑统一到 `tokio`。

## 2.4 资源与多媒体

- 棋子：SVG（先固定一套）
- 棋盘：PNG/JPG 贴图 + 程序绘制网格
- 音效：`rodio`（后置到第 4 阶段）

## 3. 目录结构建议

```text
rshogi/
├── assets/
│   ├── pieces/
│   ├── boards/
│   └── sounds/
├── src/
│   ├── main.rs
│   ├── app/
│   │   ├── state.rs        # AppState
│   │   ├── action.rs       # UI/Engine 动作
│   │   └── update.rs       # 单向数据流更新
│   ├── core/
│   │   ├── game.rs         # 棋局状态与规则封装
│   │   └── sfen.rs         # SFEN 转换
│   ├── engine/
│   │   ├── process.rs      # 引擎进程管理
│   │   ├── protocol.rs     # USI 状态机与解析
│   │   └── bridge.rs       # EngineCommand/EngineEvent
│   └── ui/
│       ├── board.rs
│       ├── hand.rs
│       ├── analysis.rs
│       └── settings.rs
└── doc/
    ├── plan.md
    ├── discussion-summary.md
    └── implementation-roadmap.md
```

## 4. 分阶段实现步骤

## Phase 0：骨架与可运行窗口（1-2 天）

目标：

- 工程可编译可启动
- 有基础 GPUI 窗口和空布局
- 定义核心状态结构

交付：

1. `AppState`、`Action`、`update()` 最小闭环
2. 棋盘区域、侧边栏区域占位
3. 基础日志与错误输出

完成标准：

- `cargo run` 可打开窗口
- 点击按钮可触发一次状态更新并重绘

## Phase 1：棋盘与规则闭环（3-5 天）

目标：

- 从 SFEN 正确渲染棋盘
- 只允许合法走子
- 支持吃子并更新手牌

交付：

1. SFEN -> 内部状态 -> UI 渲染
2. 点击/拖拽走子交互
3. 合法性判断（轮次、非法着拒绝）

完成标准：

- 初始局面可完整走棋
- 非法操作不会污染状态

## Phase 2：将棋完整交互（3-5 天）

目标：

- 支持驹台打入
- 支持升变/不升变选择
- 支持基本历史记录与悔棋（可选）

交付：

1. 驹台组件与打入流程
2. 升变弹窗与规则判断
3. 历史步记录（至少 USI 列表）

完成标准：

- 一盘标准将棋可从开局下到中盘，规则表现正确

## Phase 3：USI 引擎接入（4-7 天）

目标：

- 跑通“人走一步 -> 引擎返回 bestmove -> 自动落子”

交付：

1. 引擎子进程管理（启动/停止/异常处理）
2. USI 状态机：
   - `usi`
   - `isready`
   - `usinewgame`
   - `position ...`
   - `go ...`
   - `bestmove`
3. `EngineCommand / EngineEvent` 通道

完成标准：

- 与一款指定引擎（建议 YaneuraOu）稳定对弈 20+ 手无卡死

## Phase 4：分析面板与参数（4-7 天）

目标：

- 显示引擎思考过程核心信息

交付：

1. 分析栏展示：
   - 分数（cp/mate）
   - 深度
   - PV 主线
2. 基础参数配置：
   - 线程数
   - hash
   - movetime/depth 模式
3. 棋盘标注（最佳着箭头，可选）

完成标准：

- 分析信息可随引擎输出实时更新
- 调整参数后新一轮搜索生效

## Phase 5：打磨与发布前（持续）

目标：

- 可用性和稳定性达到日常可玩

交付：

1. 音效、主题、棋子皮肤切换
2. 棋谱导入导出（KIF/CSA 选一个先做）
3. 性能优化与崩溃恢复
4. 打包发布（Linux/macOS/Windows 视你的平台优先级）

## 5. 工程实现原则

1. 单向数据流优先：UI 不直接改棋局，统一通过 `Action`
2. 引擎与 UI 强解耦：引擎只发事件，不依赖 UI 类型
3. 每阶段保持“可运行”
4. 先单引擎跑通，再做兼容
5. 先标准将棋，再做变体

## 6. 首批任务清单（建议这周执行）

1. 初始化 `Cargo.toml` 与模块目录
2. 写 `AppState`/`Action`/`update` 最小实现
3. 完成 9x9 棋盘渲染和 SFEN 加载
4. 接规则库做合法走子
5. 定义 `EngineBridge` 接口（先 mock，不连真实引擎）

## 7. 风险与决策点

高风险项：

1. GPUI 文档少，调试成本高
2. USI 引擎行为差异（option 名、输出格式）
3. 规则库与 UI 数据结构不匹配

建议提前决策：

1. 第一目标引擎固定为哪一个（建议 YaneuraOu）
2. 第一版是否做多变体（建议不做）
3. 是否引入 `tokio`（建议 Phase 3 再定）

---

这份文档定位是“执行手册”，后续你每完成一个阶段，可以在对应章节补充“实际结果/偏差/下一步调整”。
